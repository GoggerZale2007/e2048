<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>e2048</title>
    <style>
        /* =========================================================
           I. CSS VARIABLES (Classic Colors)
           ========================================================= */
        :root {
            /* 2048 Theme Colors */
            --bg-2048: #faf8ef;
            --text-2048: #776e65;
            --board-2048: #bbada0;
            --cell-2048: rgba(238, 228, 218, 0.35);
            --score-bg: #bbada0;
            
            /* Block Puzzle Theme Colors */
            --bp-bg: #a0745b;
            --bp-board: #674332;
            --bp-cell: #573727;
            --bp-green: #71b965;
            --bp-beige: #dac6a3;
        }

        /* =========================================================
           II. GLOBAL RESET & TYPOGRAPHY
           ========================================================= */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: "Clear Sans", Arial, sans-serif;
            background: var(--bg-2048);
            color: var(--text-2048);
            transition: background 0.3s ease-in-out;
        }

        /* =========================================================
           III. UI FRAMEWORK & NAVIGATION
           ========================================================= */
        .view {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            background: inherit;
            z-index: 10;
            overflow-y: auto;
            padding: 20px 0;
        }

        .active-view {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* Buttons */
        .btn {
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            padding: 12px 24px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            margin: 5px;
            transition: 0.1s;
        }

        .btn:active {
            transform: translateY(2px);
            opacity: 0.8;
        }

        /* Inputs */
        .input-field {
            padding: 14px;
            border-radius: 5px;
            border: 2px solid #bbada0;
            width: 280px;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        /* =========================================================
           IV. OVERLAYS & TOAST NOTIFICATIONS
           ========================================================= */
        #toast {
            position: fixed;
            top: -150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 12px 24px;
            border-radius: 30px;
            transition: top 0.4s ease;
            z-index: 10000;
            font-weight: bold;
            pointer-events: none;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(250, 248, 239, 0.85);
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            touch-action: none;
        }

        /* =========================================================
           V. 2048 GAME UI
           ========================================================= */
        .top-header {
            width: 340px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .score-box {
            background: var(--score-bg);
            padding: 5px 15px;
            border-radius: 3px;
            color: white;
            text-align: center;
            min-width: 60px;
        }

        .score-label {
            display: block;
            font-size: 11px;
            font-weight: bold;
            color: #eee4da;
            margin-bottom: -2px;
        }

        .score-val {
            font-size: 20px;
            font-weight: bold;
        }

        .game-wrapper {
            position: relative;
            width: 340px;
            height: 340px;
            background: var(--board-2048);
            border-radius: 6px;
            padding: 10px;
            touch-action: none;
        }

        .grid-bg {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            width: 100%;
            height: 100%;
        }

        .grid-cell {
            background: var(--cell-2048);
            border-radius: 3px;
        }

        .tile-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            width: 320px;
            height: 320px;
        }

        /* =========================================================
           VI. 2048 TILE ANIMATIONS & COLORS
           ========================================================= */
        .tile {
            position: absolute;
            width: 72.5px;
            height: 72.5px;
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 32px;
            transition: transform 120ms ease-in-out;
            z-index: 10;
        }

        .t-new {
            animation: appear 200ms ease-out forwards;
        }

        .t-merged {
            z-index: 20;
            animation: pop 200ms ease-in-out forwards;
        }

        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pop {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Tile Specific Colors */
        .t2 { background: #eee4da; color: #776e65; }
        .t4 { background: #ede0c8; color: #776e65; }
        .t8 { background: #f2b179; color: #f9f6f2; }
        .t16 { background: #f59563; color: #f9f6f2; }
        .t32 { background: #f67c5f; color: #f9f6f2; }
        .t64 { background: #f65e3b; color: #f9f6f2; }
        .t128 { background: #edcf72; color: #f9f6f2; font-size: 28px; }
        .t256 { background: #edcc61; color: #f9f6f2; font-size: 28px; }
        .t512 { background: #edc850; color: #f9f6f2; font-size: 28px; }
        .t1024 { background: #edc53f; color: #f9f6f2; font-size: 24px; }
        .t2048 { background: #edc22e; color: #f9f6f2; font-size: 24px; }
        .t4096 { background: #3c3a32; color: #f9f6f2; }
        .t131072 { background: #000; color: #00f2ff; text-shadow: 0 0 8px #00f2ff; }

        /* =========================================================
           VII. BLOCK PUZZLE UI
           ========================================================= */
        .bp-grid {
            display: grid;
            grid-template-columns: repeat(8, 40px);
            gap: 2px;
            background: var(--bp-board);
            padding: 8px;
            border-radius: 4px;
        }

        .bp-slot {
            width: 40px;
            height: 40px;
            background: var(--bp-cell);
            border-radius: 2px;
        }

        .bp-filled-green {
            background: var(--bp-green);
            box-shadow: inset 2px 2px 0 rgba(255, 255, 255, 0.3);
        }

        .bp-filled-beige {
            background: var(--bp-beige);
            box-shadow: inset 2px 2px 0 rgba(255, 255, 255, 0.4);
        }

        .bp-ghost {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }
        
        .tray {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 360px;
            height: 120px;
            margin-top: 30px;
        }

        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="toast">Achievement Unlocked!</div>

    <div id="view-auth" class="view active-view" style="justify-content: center;">
        <h1 style="font-size: 80px; margin: 0 0 40px 0;">e2048</h1>
        
        <input type="text" id="reg-u" placeholder="Username" class="input-field" autocomplete="off">
        <input type="password" id="reg-p" placeholder="Password" class="input-field">
        
        <button class="btn" style="width: 280px;" onclick="auth.login()">Login</button>
        <button class="btn" style="width: 280px; background: #71b965;" onclick="auth.register()">Create Account</button>
    </div>

    <div id="view-home" class="view">
        <h2 id="welcome-msg" style="font-size: 32px; margin-bottom: 40px;">Welcome</h2>
        
        <button class="btn" style="width: 280px;" onclick="sys.nav('view-modes')">2048 Modes</button>
        <button class="btn" style="width: 280px; background: #674332;" onclick="sys.nav('view-bp')">Block Puzzle</button>
        <button class="btn" style="width: 280px; background: #555;" onclick="sys.nav('view-stats')">Player Profile</button>
    </div>

    <div id="view-modes" class="view">
        <div class="top-header">
            <button class="btn" style="padding: 5px 15px;" onclick="sys.nav('view-home')">Back</button>
            <h2 style="margin: 0;">Game Modes</h2>
            <div style="width: 50px;"></div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0; width: 320px;">
            <button class="btn" onclick="game2048.init(1024)">1024</button>
            <button class="btn" onclick="game2048.init(2048)">2048</button>
            <button class="btn" onclick="game2048.init(4096)">4096</button>
            <button class="btn" onclick="game2048.init(8192)">8192</button>
            <button class="btn" onclick="game2048.init(16384)">16384</button>
            <button class="btn" onclick="game2048.init(32768)">32768</button>
            <button class="btn" onclick="game2048.init(65536)">65536</button>
            <button class="btn" onclick="game2048.init(131072)">131072</button>
        </div>
        
        <button class="btn" style="width: 320px; background: #f65e3b;" onclick="game2048.init(Infinity, 60)">1 Minute Challenge</button>
        <button class="btn" style="width: 320px; background: #71b965;" onclick="let s = prompt('Enter time in seconds:', '120'); if(s) game2048.init(Infinity, parseInt(s))">Custom Time</button>
        <button class="btn" style="width: 320px; background: #333;" onclick="game2048.init(Infinity)">Endless Mode</button>
    </div>

    <div id="view-2048" class="view">
        <div class="top-header">
            <h2 id="display-target" style="margin: 0; font-size: 32px;">2048</h2>
            <div style="display: flex; gap: 8px;">
                <div class="score-box">
                    <span class="score-label">SCORE</span>
                    <span class="score-val" id="score-2048">0</span>
                </div>
                <div class="score-box">
                    <span class="score-label">BEST</span>
                    <span class="score-val" id="best-2048">0</span>
                </div>
            </div>
        </div>
        
        <div id="timer-row" style="display: none; width: 340px; margin-bottom: 10px; background: #f65e3b; color: white; padding: 10px; border-radius: 4px; text-align: center; font-weight: bold;">
            TIME REMAINING: <span id="timer-val" style="font-size: 20px;">0:00</span>
        </div>
        
        <div class="game-wrapper" id="board-2048">
            <div class="grid-bg">
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
            </div>
            
            <div class="tile-layer" id="tile-layer"></div>
            
            <div class="overlay" id="over-2048">
                <h1 id="over-msg" style="color: #776e65;">Game Over</h1>
                <button class="btn" onclick="game2048.init(game2048.target, game2048.initTime)">Try Again</button>
                <button class="btn" style="background: #555;" onclick="sys.nav('view-modes')">Menu</button>
            </div>
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 20px; width: 340px;">
            <button class="btn" style="flex: 1; background: #bbada0;" onclick="game2048.undo()">↩ Undo</button>
        </div>
    </div>

    <div id="view-bp" class="view" style="background: var(--bp-bg);">
        <div class="top-header">
            <h2 style="color: white; margin: 0;">Score: <span id="score-bp">0</span></h2>
            <button class="btn" style="background: none; box-shadow: none; font-size: 24px;" onclick="sys.nav('view-home')">✕</button>
        </div>
        
        <div class="bp-grid" id="bp-grid"></div>
        <div class="tray" id="tray"></div>
        
        <div class="overlay" id="over-bp" style="background: rgba(103, 67, 50, 0.9);">
            <h1 style="color: white;">Out of Moves</h1>
            <button class="btn" style="background: #71b965;" onclick="gameBP.init()">Retry</button>
        </div>
    </div>

    <div id="view-stats" class="view">
        <h2 style="font-size: 32px; margin-bottom: 20px;">Player Profile</h2>
        <div style="background: white; padding: 25px; border-radius: 8px; width: 320px; font-size: 18px; line-height: 1.6;">
            <p>Total Merges: <b id="stat-merges" style="float: right;">0</b></p>
            <p>Highest Score: <b id="stat-high" style="float: right;">0</b></p>
            
            <hr style="border: none; border-top: 2px dashed #eee; margin: 20px 0;">
            
            <h3 style="margin: 0 0 10px 0; color: #bbada0;">Achievements</h3>
            <div id="achievements-list" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
        </div>
        <button class="btn" style="margin-top: 30px; width: 320px;" onclick="sys.nav('view-home')">Back</button>
    </div>

    <script>
        /**
         * AUDIO SYNTHESIZER MODULE
         * Generates sound waves via the Web Audio API natively.
         */
        const sfx = {
            ctx: null,
            
            /**
             * Core tone generator function
             */
            play(frequency, type, duration, volume) {
                if (!sys.soundOn) return; 
                
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = type; 
                osc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(volume, this.ctx.currentTime); 
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                
                osc.connect(gain); 
                gain.connect(this.ctx.destination); 
                
                osc.start(); 
                osc.stop(this.ctx.currentTime + duration);
            },
            
            merge() { 
                this.play(400, 'sine', 0.15, 0.1); 
            },
            
            wood() { 
                this.play(200, 'square', 0.05, 0.05); 
            },
            
            win() { 
                this.play(600, 'sine', 0.1, 0.1); 
                setTimeout(() => this.play(800, 'sine', 0.3, 0.1), 100); 
            }
        };

        /**
         * SYSTEM CORE MANAGER
         * Handles Navigation, Databases, Achievements, and Input Binding.
         */
        const sys = {
            db: { users: {} }, 
            user: null, 
            soundOn: true, 
            toastTimer: null,
            
            init() {
                const savedData = localStorage.getItem('e2048_plat_db'); 
                if (savedData) {
                    this.db = JSON.parse(savedData);
                }
                this.bindInputs();
            },
            
            nav(id) {
                // Instantly hide any visible toast notifications during view changes
                document.getElementById('toast').style.top = "-150px";
                
                // Toggle active view classes
                document.querySelectorAll('.view').forEach(v => {
                    v.classList.remove('active-view');
                });
                document.getElementById(id).classList.add('active-view');
                
                // Set the global body background dependent on the game mode
                document.body.style.background = id === 'view-bp' ? 'var(--bp-bg)' : 'var(--bg-2048)';
                
                // Specific view initializers
                if (id === 'view-bp') {
                    gameBP.init();
                }
                if (id === 'view-stats') {
                    this.updateProfile();
                }
            },
            
            toast(message) {
                const toastEl = document.getElementById('toast'); 
                toastEl.innerText = message; 
                toastEl.style.top = "20px";
                
                if (this.toastTimer) {
                    clearTimeout(this.toastTimer);
                }
                
                // Slide back up after 3 seconds
                this.toastTimer = setTimeout(() => { 
                    toastEl.style.top = "-150px"; 
                }, 3000);
            },
            
            save() { 
                localStorage.setItem('e2048_plat_db', JSON.stringify(this.db)); 
            },
            
            checkAchievement(achievementName) {
                if (!this.user) return; 
                
                let currentUser = this.db.users[this.user]; 
                
                if (!currentUser.achievements) {
                    currentUser.achievements = [];
                }
                
                if (!currentUser.achievements.includes(achievementName)) { 
                    currentUser.achievements.push(achievementName); 
                    this.save(); 
                    this.toast("Achievement: " + achievementName); 
                    sfx.win(); 
                }
            },
            
            updateProfile() {
                if (!this.user) return; 
                
                const currentUser = this.db.users[this.user];
                
                document.getElementById('stat-merges').innerText = currentUser.totalMerges || 0;
                document.getElementById('stat-high').innerText = currentUser.best2048 || 0;
                
                const list = document.getElementById('achievements-list'); 
                list.innerHTML = '';
                
                if (!currentUser.achievements || currentUser.achievements.length === 0) {
                    list.innerHTML = '<span style="color: #aaa;">No achievements yet.</span>';
                } else {
                    currentUser.achievements.forEach(achievement => {
                        const badge = document.createElement('span'); 
                        badge.style = "background: #edc22e; color: white; padding: 4px 10px; border-radius: 20px; font-size: 12px; font-weight: bold;";
                        badge.innerText = achievement; 
                        list.appendChild(badge);
                    });
                }
            },
            
            bindInputs() {
                let touchStartX, touchStartY; 
                const board = document.getElementById('board-2048');
                
                board.addEventListener('touchstart', e => { 
                    touchStartX = e.touches[0].clientX; 
                    touchStartY = e.touches[0].clientY; 
                }, { passive: true });
                
                board.addEventListener('touchend', e => {
                    let deltaX = e.changedTouches[0].clientX - touchStartX;
                    let deltaY = e.changedTouches[0].clientY - touchStartY;
                    
                    if (Math.abs(deltaX) > 30 || Math.abs(deltaY) > 30) {
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            game2048.move(deltaX > 0 ? 'R' : 'L');
                        } else {
                            game2048.move(deltaY > 0 ? 'D' : 'U');
                        }
                    }
                }, { passive: true });
                
                window.addEventListener('keydown', e => { 
                    if (e.key.includes('Arrow')) {
                        // ArrowUp returns 'U', ArrowDown returns 'D', etc.
                        game2048.move(e.key[5][0]); 
                    }
                });
            }
        };

        /**
         * AUTHENTICATION CONTROLLER
         * Secure local login logic and profile creation.
         */
        const auth = {
            login() { 
                const username = document.getElementById('reg-u').value.trim(); 
                const password = document.getElementById('reg-p').value.trim();
                
                if (!username) {
                    return alert("Please enter a username.");
                }
                
                if (sys.db.users[username]) {
                    if (sys.db.users[username].pass === password || !sys.db.users[username].pass) {
                        this.complete(username);
                    } else {
                        alert("Incorrect password!");
                    }
                } else {
                    alert("Account not found! Please click 'Create Account'.");
                }
            },
            
            register() {
                const username = document.getElementById('reg-u').value.trim();
                const password = document.getElementById('reg-p').value.trim();
                
                if (!username) {
                    return alert("Please enter a username.");
                }
                
                if (username.length < 3) {
                    return alert("Username too short.");
                }
                
                if (sys.db.users[username]) {
                    alert("Username exists! Please Login.");
                } else { 
                    sys.db.users[username] = { 
                        pass: password, 
                        achievements: [], 
                        best2048: 0, 
                        totalMerges: 0 
                    }; 
                    sys.save(); 
                    this.complete(username); 
                }
            },
            
            complete(username) { 
                sys.user = username; 
                document.getElementById('welcome-msg').innerText = "Hello, " + username; 
                sys.nav('view-home'); 
            }
        };

        /**
         * 2048 GAME ENGINE
         * Manages grid arrays, sliding physics, merging math, DOM diffing, and game states.
         */
        const game2048 = {
            grid: [], 
            score: 0, 
            target: 2048, 
            history: [], 
            timer: null, 
            timeLeft: 0, 
            initTime: 0,
            
            init(targetValue, seconds = 0) {
                this.target = targetValue; 
                this.score = 0; 
                this.grid = Array(16).fill(null); 
                this.timeLeft = seconds; 
                this.initTime = seconds;
                
                document.getElementById('over-2048').style.display = 'none';
                document.getElementById('display-target').innerText = targetValue === Infinity ? "ENDLESS" : targetValue;
                document.getElementById('timer-row').style.display = seconds > 0 ? 'block' : 'none';
                
                clearInterval(this.timer); 
                if (seconds > 0) {
                    this.startTimer();
                }
                
                if (sys.user) {
                    document.getElementById('best-2048').innerText = sys.db.users[sys.user].best2048 || 0;
                }
                
                // Spawn the first two starting tiles
                this.spawn(); 
                this.spawn(); 
                this.render(); 
                
                sys.nav('view-2048');
            },
            
            startTimer() {
                this.timer = setInterval(() => {
                    this.timeLeft--; 
                    
                    const minutes = Math.floor(this.timeLeft / 60);
                    const seconds = this.timeLeft % 60;
                    
                    document.getElementById('timer-val').innerText = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                    
                    if (this.timeLeft <= 0) { 
                        clearInterval(this.timer); 
                        this.gameOver("Time's Up!"); 
                    }
                }, 1000);
            },
            
            spawn() {
                const emptySlots = this.grid.map((val, index) => val === null ? index : null).filter(val => val !== null);
                
                if (emptySlots.length > 0) {
                    const randomSlot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
                    
                    this.grid[randomSlot] = { 
                        val: Math.random() < 0.9 ? 2 : 4, 
                        // Creates a unique ID so the CSS tracks the tile perfectly across DOM renders
                        id: 't_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                        isNew: true
                    };
                }
            },
            
            /**
             * The Render function utilizes DOM Diffing to ensure CSS slide transitions fire properly.
             */
            render() {
                const layer = document.getElementById('tile-layer'); 
                const currentIds = new Set(this.grid.filter(t => t).map(t => t.id));
                
                // 1. Remove dead tiles gracefully so merge animations have time to finish
                Array.from(layer.children).forEach(node => {
                    if (!currentIds.has(node.dataset.id)) {
                        node.style.zIndex = 5; 
                        setTimeout(() => node.remove(), 150); 
                    }
                });
                
                // 2. Map existing logic array to DOM elements
                this.grid.forEach((tile, index) => {
                    if (!tile) return; 
                    
                    let node = document.querySelector(`.tile[data-id='${tile.id}']`);
                    
                    if (!node) {
                        node = document.createElement('div');
                        node.dataset.id = tile.id;
                        layer.appendChild(node);
                    }
                    
                    // Force a browser reflow to guarantee CSS animation restarts
                    void node.offsetWidth;
                    
                    node.className = `tile t${tile.val} ${tile.isNew ? 't-new' : ''} ${tile.merged ? 't-merged' : ''}`; 
                    
                    // Direct transform injection for smooth coordinate sliding
                    const x = (index % 4) * 82.5;
                    const y = Math.floor(index / 4) * 82.5;
                    
                    node.style.transform = `translate(${x}px, ${y}px) scale(${tile.merged ? 1.1 : 1})`;
                    
                    if (tile.merged) {
                        setTimeout(() => {
                            node.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                        }, 150);
                    }
                    
                    node.innerText = tile.val; 
                    
                    tile.isNew = false; 
                    tile.merged = false;
                });
                
                // Update Scoreboard
                document.getElementById('score-2048').innerText = this.score;
                
                if (sys.user && this.score > sys.db.users[sys.user].best2048) { 
                    sys.db.users[sys.user].best2048 = this.score; 
                    sys.save(); 
                }
            },
            
            move(direction) {
                // Prevent swipes if overlay is blocking the board
                if (document.getElementById('over-2048').style.display === 'flex') {
                    return;
                }
                
                let moved = false; 
                this.history.push(JSON.stringify(this.grid));
                
                const getRowIndices = (rowIndex) => {
                    if (direction === 'L') return [rowIndex * 4, rowIndex * 4 + 1, rowIndex * 4 + 2, rowIndex * 4 + 3];
                    if (direction === 'R') return [rowIndex * 4 + 3, rowIndex * 4 + 2, rowIndex * 4 + 1, rowIndex * 4];
                    if (direction === 'U') return [rowIndex, rowIndex + 4, rowIndex + 8, rowIndex + 12];
                    return [rowIndex + 12, rowIndex + 8, rowIndex + 4, rowIndex];
                };
                
                for (let i = 0; i < 4; i++) {
                    let indices = getRowIndices(i);
                    // Deep copy current row to prevent reference leaking to history
                    let row = indices.map(idx => this.grid[idx] ? { ...this.grid[idx] } : null).filter(val => val !== null);
                    
                    // Calculate Merges
                    for (let j = 0; j < row.length - 1; j++) {
                        if (row[j].val === row[j + 1].val) {
                            row[j].val *= 2; 
                            row[j].merged = true; 
                            this.score += row[j].val; 
                            
                            // Splice removes the consumed tile and shifts the array down
                            row.splice(j + 1, 1); 
                            moved = true; 
                            sfx.merge();
                            
                            if (sys.user) { 
                                sys.db.users[sys.user].totalMerges++; 
                                sys.save(); 
                            }
                            
                            if (row[j].val === this.target) {
                                sys.checkAchievement("Reached " + this.target);
                            }
                        }
                    }
                    
                    // Pad array back to length 4 with nulls
                    while (row.length < 4) {
                        row.push(null);
                    }
                    
                    // Overwrite actual grid and verify if any movement occurred
                    indices.forEach((idx, j) => { 
                        if (JSON.stringify(this.grid[idx]) !== JSON.stringify(row[j])) {
                            moved = true; 
                        }
                        this.grid[idx] = row[j]; 
                    });
                }
                
                if (moved) { 
                    this.spawn(); 
                    this.render(); 
                    
                    if (this.isFull() && !this.canMove()) {
                        this.gameOver("No Moves Left!"); 
                    }
                } else {
                    // Revert history if swipe was ignored (nothing shifted)
                    this.history.pop(); 
                }
            },
            
            isFull() { 
                return !this.grid.includes(null); 
            },
            
            canMove() {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (this.grid[i * 4 + j].val === this.grid[i * 4 + j + 1].val) return true;
                        if (this.grid[j * 4 + i].val === this.grid[(j + 1) * 4 + i].val) return true;
                    }
                }
                return false;
            },
            
            undo() { 
                if (this.history.length) { 
                    this.grid = JSON.parse(this.history.pop()); 
                    this.render(); 
                } 
            },
            
            gameOver(message) { 
                document.getElementById('over-msg').innerText = message; 
                document.getElementById('over-2048').style.display = 'flex'; 
                clearInterval(this.timer); 
            }
        };

        /**
         * BLOCK PUZZLE ENGINE
         * Drag-and-drop physics, boundary checks, grid alignment, and 10x10 style logic.
         */
        const gameBP = {
            board: Array(64).fill(0), 
            score: 0,
            
            shapes: [ 
                { m: [[1,1],[1,1]], c: 'bp-filled-green' }, 
                { m: [[1,1,1,1]], c: 'bp-filled-beige' }, 
                { m: [[1,1,1],[0,1,0]], c: 'bp-filled-beige' }, 
                { m: [[1,0],[1,0],[1,1]], c: 'bp-filled-green' }, 
                { m: [[1,1,0],[0,1,1]], c: 'bp-filled-beige' } 
            ],
            
            init() {
                this.board.fill(0); 
                this.score = 0; 
                
                document.getElementById('over-bp').style.display = 'none';
                
                const grid = document.getElementById('bp-grid'); 
                grid.innerHTML = '';
                
                for (let i = 0; i < 64; i++) { 
                    const slot = document.createElement('div'); 
                    slot.className = 'bp-slot'; 
                    slot.id = `bp-c-${i}`; 
                    grid.appendChild(slot); 
                }
                
                this.spawn();
            },
            
            spawn() {
                const tray = document.getElementById('tray'); 
                tray.innerHTML = '';
                
                for (let i = 0; i < 3; i++) {
                    const shapeObj = this.shapes[Math.floor(Math.random() * this.shapes.length)];
                    const div = document.createElement('div');
                    
                    div.style.display = 'grid'; 
                    div.style.gridTemplateColumns = `repeat(${shapeObj.m[0].length}, 20px)`; 
                    div.style.gap = '2px';
                    
                    shapeObj.m.flat().forEach(val => { 
                        const block = document.createElement('div'); 
                        block.style.width = '20px'; 
                        block.style.height = '20px'; 
                        block.style.borderRadius = '2px'; 
                        
                        if (val) {
                            block.className = shapeObj.c; 
                        }
                        
                        div.appendChild(block); 
                    });
                    
                    const startDrag = (e) => this.drag(e.touches ? e.touches[0] : e, div, shapeObj.m, shapeObj.c);
                    
                    div.onmousedown = startDrag; 
                    div.ontouchstart = startDrag; 
                    
                    tray.appendChild(div);
                }
            },
            
            drag(pointer, element, matrix, colorClass) {
                const clone = element.cloneNode(true); 
                clone.className = 'dragging'; 
                
                clone.style.gridTemplateColumns = `repeat(${matrix[0].length}, 40px)`;
                
                Array.from(clone.children).forEach(child => { 
                    child.style.width = '40px'; 
                    child.style.height = '40px'; 
                });
                
                document.body.appendChild(clone);
                
                const handleMove = (e) => {
                    const p = e.touches ? e.touches[0] : e;
                    
                    clone.style.left = p.clientX - (matrix[0].length * 20) + 'px'; 
                    clone.style.top = p.clientY - (matrix.length * 60) + 'px';
                    
                    document.querySelectorAll('.bp-ghost').forEach(g => {
                        g.classList.remove('bp-ghost');
                    });
                    
                    const rect = document.getElementById('bp-grid').getBoundingClientRect();
                    const targetCol = Math.round((p.clientX - rect.left - (matrix[0].length * 20)) / 42);
                    const targetRow = Math.round((p.clientY - rect.top - (matrix.length * 60)) / 42);
                    
                    if (this.canPlace(matrix, targetRow, targetCol)) {
                        for (let i = 0; i < matrix.length; i++) {
                            for (let j = 0; j < matrix[0].length; j++) {
                                if (matrix[i][j]) {
                                    document.getElementById(`bp-c-${(targetRow + i) * 8 + (targetCol + j)}`).classList.add('bp-ghost');
                                }
                            }
                        }
                    }
                };
                
                const handleEnd = (e) => {
                    const p = e.changedTouches ? e.changedTouches[0] : e;
                    
                    const rect = document.getElementById('bp-grid').getBoundingClientRect();
                    const targetCol = Math.round((p.clientX - rect.left - (matrix[0].length * 20)) / 42);
                    const targetRow = Math.round((p.clientY - rect.top - (matrix.length * 60)) / 42);
                    
                    if (this.canPlace(matrix, targetRow, targetCol)) {
                        for (let i = 0; i < matrix.length; i++) {
                            for (let j = 0; j < matrix[0].length; j++) {
                                if (matrix[i][j]) { 
                                    this.board[(targetRow + i) * 8 + (targetCol + j)] = 1; 
                                    document.getElementById(`bp-c-${(targetRow + i) * 8 + (targetCol + j)}`).className = `bp-slot ${colorClass}`; 
                                }
                            }
                        }
                        
                        sfx.wood(); 
                        element.style.visibility = 'hidden'; 
                        this.score += (matrix.flat().filter(v => v).length * 10);
                        
                        this.clearLines(); 
                        
                        document.getElementById('score-bp').innerText = this.score;
                        
                        if (Array.from(element.parentNode.children).every(c => c.style.visibility === 'hidden')) {
                            this.spawn();
                        }
                    }
                    
                    clone.remove(); 
                    
                    document.querySelectorAll('.bp-ghost').forEach(g => {
                        g.classList.remove('bp-ghost');
                    });
                    
                    window.removeEventListener('mousemove', handleMove); 
                    window.removeEventListener('mouseup', handleEnd);
                    window.removeEventListener('touchmove', handleMove); 
                    window.removeEventListener('touchend', handleEnd);
                };
                
                window.addEventListener('mousemove', handleMove); 
                window.addEventListener('mouseup', handleEnd);
                window.addEventListener('touchmove', handleMove, { passive: false }); 
                window.addEventListener('touchend', handleEnd);
            },
            
            canPlace(matrix, row, col) {
                if (row < 0 || col < 0 || row + matrix.length > 8 || col + matrix[0].length > 8) {
                    return false;
                }
                
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] && this.board[(row + i) * 8 + (col + j)]) {
                            return false;
                        }
                    }
                }
                
                return true;
            },
            
            clearLines() {
                let rowsToClear = [];
                let colsToClear = [];
                
                for (let i = 0; i < 8; i++) {
                    if (this.board.slice(i * 8, i * 8 + 8).every(v => v)) {
                        rowsToClear.push(i);
                    }
                    
                    let tempCol = []; 
                    for (let j = 0; j < 8; j++) {
                        tempCol.push(this.board[j * 8 + i]);
                    }
                    
                    if (tempCol.every(v => v)) {
                        colsToClear.push(i);
                    }
                }
                
                rowsToClear.forEach(r => { 
                    for (let i = 0; i < 8; i++) { 
                        this.board[r * 8 + i] = 0; 
                        document.getElementById(`bp-c-${r * 8 + i}`).className = 'bp-slot'; 
                    } 
                });
                
                colsToClear.forEach(c => { 
                    for (let i = 0; i < 8; i++) { 
                        this.board[i * 8 + c] = 0; 
                        document.getElementById(`bp-c-${i * 8 + c}`).className = 'bp-slot'; 
                    } 
                });
                
                if (rowsToClear.length > 0 || colsToClear.length > 0) { 
                    this.score += (rowsToClear.length + colsToClear.length) * 100; 
                    sfx.win(); 
                    
                    if (rowsToClear.length + colsToClear.length >= 3) {
                        sys.checkAchievement("Combo Master"); 
                    }
                }
            }
        };

        // Initialize application on load
        window.onload = () => {
            sys.init();
        };
    </script>
</body>
</html>
