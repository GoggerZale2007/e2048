<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>e2048</title>
    <style>
        /* =========================================================
           I. CSS VARIABLES & THEMES
           ========================================================= */
        :root {
            /* Classic 2048 Theme */
            --bg-2048: #faf8ef; 
            --text-2048: #776e65; 
            --board-2048: #bbada0; 
            --cell-2048: rgba(238, 228, 218, 0.35); 
            --score-bg: #bbada0;
            
            /* Block Puzzle Wood Theme */
            --bp-bg: #a0745b; 
            --bp-board: #674332; 
            --bp-cell: #573727; 
            --bp-green: #71b965; 
            --bp-beige: #dac6a3;
        }

        /* =========================================================
           II. GLOBAL RESET
           ========================================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
            outline: none; 
            user-select: none; 
        }

        body { 
            margin: 0; 
            padding: 0; 
            height: 100vh; 
            width: 100vw; 
            overflow: hidden; 
            font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif; 
            background: var(--bg-2048); 
            color: var(--text-2048); 
            transition: background 0.4s ease; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }

        /* =========================================================
           III. UI FRAMEWORK & NAVIGATION
           ========================================================= */
        .view { 
            display: none; 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            background: inherit; 
            z-index: 10; 
            padding: 20px 0; 
            overflow-y: auto; 
        }

        .active-view { 
            display: flex; 
            animation: slideIn 0.4s cubic-bezier(0.25, 1, 0.5, 1); 
        }

        @keyframes slideIn { 
            from { 
                opacity: 0; 
                transform: translateY(15px); 
            } 
            to { 
                opacity: 1; 
                transform: translateY(0); 
            } 
        }

        /* Standard Button Styles */
        .btn { 
            background: #8f7a66; 
            color: #f9f6f2; 
            border: none; 
            padding: 14px 28px; 
            border-radius: 6px; 
            font-weight: bold; 
            font-size: 16px; 
            cursor: pointer; 
            text-transform: uppercase; 
            margin: 6px; 
            transition: transform 0.1s, opacity 0.2s; 
            box-shadow: 0 4px 0 rgba(0,0,0,0.15); 
        }

        .btn:active { 
            transform: translateY(4px); 
            box-shadow: none; 
        }

        /* Button Color Variants */
        .btn-green { 
            background: #71b965; 
        } 
        
        .btn-blue { 
            background: #5da5da; 
        } 
        
        .btn-red { 
            background: #e74c3c; 
        } 
        
        .btn-dark { 
            background: #555; 
        }

        /* Input Fields for Login/Register */
        .input-field { 
            padding: 15px; 
            border-radius: 6px; 
            border: 2px solid var(--board-2048); 
            width: 280px; 
            font-size: 16px; 
            margin-bottom: 12px; 
            text-align: center; 
        }

        /* Global Toast Notifications */
        #toast { 
            position: fixed; 
            top: -150px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.9); 
            color: #fff; 
            padding: 14px 30px; 
            border-radius: 40px; 
            transition: top 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28); 
            z-index: 10000; 
            font-weight: bold; 
            pointer-events: none; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); 
        }

        /* Screen Overlays (Game Over, Time Up) */
        .overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(250, 248, 239, 0.85); 
            z-index: 100; 
            display: none; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            pointer-events: all; 
            touch-action: none; 
            backdrop-filter: blur(3px); 
            border-radius: 8px; 
        }

        /* =========================================================
           IV. 2048 ENGINE & HEAVY PHYSICS
           ========================================================= */
        .top-header { 
            width: 340px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 20px; 
        }

        .score-box { 
            background: var(--score-bg); 
            padding: 8px 15px; 
            border-radius: 5px; 
            color: white; 
            text-align: center; 
            min-width: 70px; 
        }

        .score-label { 
            display: block; 
            font-size: 11px; 
            font-weight: bold; 
            color: #eee4da; 
            margin-bottom: -2px; 
        }

        .score-val { 
            font-size: 22px; 
            font-weight: bold; 
        }

        .game-wrapper { 
            position: relative; 
            width: 340px; 
            height: 340px; 
            background: var(--board-2048); 
            border-radius: 8px; 
            padding: 10px; 
            touch-action: none; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
        }

        .grid-bg { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 10px; 
            width: 100%; 
            height: 100%; 
        }

        .grid-cell { 
            background: var(--cell-2048); 
            border-radius: 4px; 
        }

        .tile-layer { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            pointer-events: none; 
            width: 320px; 
            height: 320px; 
        }

        /* Tile Physics Classes */
        .tile { 
            position: absolute; 
            width: 72.5px; 
            height: 72.5px; 
            border-radius: 4px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-weight: bold; 
            font-size: 32px; 
            z-index: 10; 
            transition: transform 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94); 
        }

        .t-new { 
            animation: appear 200ms ease-out forwards; 
        }

        .t-merged { 
            z-index: 20; 
            animation: pop 200ms ease-in-out forwards; 
        }

        .t-dying { 
            opacity: 0; 
            transform: scale(0.5); 
            transition: all 150ms ease-in; 
        }
        
        @keyframes appear { 
            0% { 
                opacity: 0; 
                transform: scale(0); 
            } 
            100% { 
                opacity: 1; 
                transform: scale(1); 
            } 
        }

        @keyframes pop { 
            0% { 
                transform: scale(1); 
            } 
            50% { 
                transform: scale(1.2); 
            } 
            100% { 
                transform: scale(1); 
            } 
        }

        /* Individual Tile Colors */
        .t2 { background:#eee4da; color:#776e65; } 
        .t4 { background:#ede0c8; color:#776e65; } 
        .t8 { background:#f2b179; color:#f9f6f2; } 
        .t16 { background:#f59563; color:#f9f6f2; } 
        .t32 { background:#f67c5f; color:#f9f6f2; } 
        .t64 { background:#f65e3b; color:#f9f6f2; } 
        .t128 { background:#edcf72; color:#f9f6f2; font-size:28px; box-shadow: 0 0 10px rgba(237, 207, 114, 0.5); } 
        .t256 { background:#edcc61; color:#f9f6f2; font-size:28px; box-shadow: 0 0 15px rgba(237, 204, 97, 0.6); } 
        .t512 { background:#edc850; color:#f9f6f2; font-size:28px; box-shadow: 0 0 20px rgba(237, 200, 80, 0.7); } 
        .t1024 { background:#edc53f; color:#f9f6f2; font-size:24px; box-shadow: 0 0 25px rgba(237, 197, 63, 0.8); } 
        .t2048 { background:#edc22e; color:#f9f6f2; font-size:24px; box-shadow: 0 0 30px rgba(237, 194, 46, 0.9); } 
        .t-super { background:#3c3a32; color:#f9f6f2; font-size:24px; }

        /* =========================================================
           V. BLOCK PUZZLE ENGINE
           ========================================================= */
        .bp-grid { 
            display: grid; 
            grid-template-columns: repeat(8, 40px); 
            gap: 2px; 
            background: var(--bp-board); 
            padding: 10px; 
            border-radius: 6px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
        }

        .bp-slot { 
            width: 40px; 
            height: 40px; 
            background: var(--bp-cell); 
            border-radius: 2px; 
            transition: background 0.2s ease; 
        }

        .bp-filled-green { 
            background: var(--bp-green); 
            box-shadow: inset 2px 2px 0 rgba(255,255,255,0.3); 
            transform: scale(0.95); 
            border-radius: 4px; 
        }

        .bp-filled-beige { 
            background: var(--bp-beige); 
            box-shadow: inset 2px 2px 0 rgba(255,255,255,0.4); 
            transform: scale(0.95); 
            border-radius: 4px; 
        }

        .bp-ghost { 
            background: rgba(255,255,255,0.25); 
            border-radius: 4px; 
            transform: scale(0.95); 
        }
        
        .tray { 
            display: flex; 
            justify-content: space-around; 
            align-items: center; 
            width: 360px; 
            height: 120px; 
            margin-top: 30px; 
            background: rgba(0,0,0,0.1); 
            border-radius: 12px; 
        }

        .dragging { 
            position: fixed; 
            z-index: 1000; 
            pointer-events: none; 
            filter: drop-shadow(0 15px 15px rgba(0,0,0,0.5)); 
        }
    </style>
</head>
<body>

    <div id="toast">Achievement Unlocked!</div>

    <div id="view-auth" class="view active-view">
        <h1 style="font-size:80px; margin: 0 0 40px 0;">e2048</h1>
        
        <input type="text" id="reg-u" placeholder="Username" class="input-field" autocomplete="off">
        <input type="password" id="reg-p" placeholder="Password" class="input-field">
        
        <button class="btn" style="width: 280px;" onclick="systemManager.login()">Sign In</button>
        <button class="btn btn-green" style="width: 280px;" onclick="systemManager.register()">Create Account</button>
    </div>

    <div id="view-home" class="view">
        <h2 id="welcome-msg" style="font-size: 32px; margin-bottom: 40px;">Welcome</h2>
        
        <button class="btn" style="width:280px;" onclick="systemManager.navigate('view-modes')">Play 2048</button>
        <button class="btn" style="width:280px; background:#674332;" onclick="systemManager.navigate('view-bp')">Block Puzzle</button>
        <button class="btn btn-dark" style="width:280px;" onclick="systemManager.navigate('view-stats')">Player Profile</button>
        <button class="btn btn-red" style="width:280px; margin-top:20px;" onclick="location.reload()">Logout</button>
    </div>

    <div id="view-modes" class="view">
        <div class="top-header">
            <button class="btn" style="padding: 8px 16px;" onclick="systemManager.navigate('view-home')">‚Üê Back</button>
            <h2 style="margin: 0;">Game Modes</h2>
            <div style="width: 60px;"></div>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin: 20px 0; width: 320px;">
            <button class="btn" onclick="gameEngine2048.initialize(1024)">1024</button>
            <button class="btn" onclick="gameEngine2048.initialize(2048)">2048</button>
            <button class="btn" onclick="gameEngine2048.initialize(4096)">4096</button>
            <button class="btn" onclick="gameEngine2048.initialize(8192)">8192</button>
            <button class="btn" onclick="gameEngine2048.initialize(16384)">16384</button>
            <button class="btn" onclick="gameEngine2048.initialize(32768)">32768</button>
            <button class="btn" onclick="gameEngine2048.initialize(65536)">65536</button>
            <button class="btn" onclick="gameEngine2048.initialize(131072)">131072</button>
        </div>
        
        <button class="btn btn-red" style="width:320px;" onclick="gameEngine2048.initialize(Infinity, 60)">1 Minute Blitz</button>
        <button class="btn btn-green" style="width:320px;" onclick="let seconds = prompt('Enter time in seconds:', '120'); if(seconds) gameEngine2048.initialize(Infinity, parseInt(seconds))">Custom Time Challenge</button>
        <button class="btn btn-dark" style="width:320px;" onclick="gameEngine2048.initialize(Infinity)">Endless Sandbox</button>
    </div>

    <div id="view-2048" class="view">
        <div class="top-header">
            <h2 id="display-target" style="margin:0; font-size: 32px;">2048</h2>
            <div style="display:flex; gap:8px;">
                <div class="score-box">
                    <span class="score-label">SCORE</span>
                    <span class="score-val" id="score-2048">0</span>
                </div>
                <div class="score-box">
                    <span class="score-label">BEST</span>
                    <span class="score-val" id="best-2048">0</span>
                </div>
            </div>
        </div>
        
        <div id="timer-row" style="display:none; width: 340px; margin-bottom:15px; background:#e74c3c; color:white; padding:10px; border-radius:6px; text-align: center; font-weight: bold; box-shadow: 0 4px 0 #c0392b;">
            TIME REMAINING: <span id="timer-val" style="font-size: 20px; margin-left: 10px;">0:00</span>
        </div>
        
        <div class="game-wrapper" id="board-2048">
            <div class="grid-bg">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
            </div>
            
            <div class="tile-layer" id="tile-layer"></div>
            
            <div class="overlay" id="over-2048">
                <h1 id="over-msg" style="color:#776e65; font-size:40px;">Game Over</h1>
                <button class="btn" onclick="gameEngine2048.initialize(gameEngine2048.target, gameEngine2048.initialTime)">Play Again</button>
                <button class="btn btn-dark" onclick="systemManager.navigate('view-modes')">Main Menu</button>
            </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:25px; width: 340px;">
            <button class="btn btn-dark" style="flex: 1;" onclick="gameEngine2048.undoLastMove()">‚Ü© Undo Move</button>
        </div>
    </div>

    <div id="view-bp" class="view" style="background:var(--bp-bg)">
        <div class="top-header">
            <h2 style="color:white; margin:0; font-size:28px;">Score: <span id="score-bp">0</span></h2>
            <button class="btn btn-red" style="padding: 10px 15px;" onclick="systemManager.navigate('view-home')">‚úï</button>
        </div>
        
        <div class="bp-grid" id="bp-grid"></div>
        <div class="tray" id="tray"></div>
        
        <div class="overlay" id="over-bp" style="background: rgba(103, 67, 50, 0.95);">
            <h1 style="color: white; font-size:40px;">No Moves</h1>
            <button class="btn btn-green" onclick="blockPuzzleEngine.initialize()">Restart Board</button>
        </div>
    </div>

    <div id="view-stats" class="view">
        <h2 style="font-size: 32px; margin-bottom: 20px;">Player Profile</h2>
        <div style="background: white; padding: 25px; border-radius: 12px; width: 320px; font-size: 18px; line-height: 1.6; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
            <p>Total Tiles Merged: <b id="stat-merges" style="float: right; color:#e74c3c;">0</b></p>
            <p>Highest 2048 Score: <b id="stat-high" style="float: right; color:#e74c3c;">0</b></p>
            <hr style="border: none; border-top: 2px dashed #eee; margin: 20px 0;">
            <h3 style="margin: 0 0 10px 0; color: #bbada0;">Trophy Case</h3>
            <div id="achievements-list" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
        </div>
        <button class="btn btn-dark" style="margin-top: 30px; width: 320px;" onclick="systemManager.navigate('view-home')">Return Home</button>
    </div>

    <script>
        /**
         * AUDIO ENGINE
         * Manages Web Audio API procedural sound generation.
         */
        const audioEngine = {
            audioContext: null,
            
            playSound(frequency, oscillatorType, durationInSeconds, volumeLevel) {
                if (!systemManager.isSoundEnabled) {
                    return; 
                }
                
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = oscillatorType; 
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(volumeLevel, this.audioContext.currentTime); 
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + durationInSeconds);
                
                oscillator.connect(gainNode); 
                gainNode.connect(this.audioContext.destination); 
                
                oscillator.start(); 
                oscillator.stop(this.audioContext.currentTime + durationInSeconds);
            },
            
            playMergeSound() { 
                this.playSound(400, 'sine', 0.15, 0.1); 
            }, 
            
            playWoodDropSound() { 
                this.playSound(200, 'square', 0.05, 0.05); 
            },
            
            playWinChime() { 
                this.playSound(600, 'sine', 0.1, 0.1); 
                setTimeout(() => {
                    this.playSound(800, 'sine', 0.3, 0.1);
                }, 100); 
            }
        };

        /**
         * SYSTEM CORE (Auth, Nav, DB)
         * Manages local storage, view routing, and user profiles.
         */
        const systemManager = {
            database: { users: {} }, 
            currentUser: null, 
            isSoundEnabled: true, 
            toastTimerId: null,
            
            initializeSystem() {
                const savedDatabase = localStorage.getItem('e2048_platinum_database'); 
                
                if (savedDatabase) {
                    this.database = JSON.parse(savedDatabase);
                }
                
                this.bindGlobalInputs();
            },
            
            login() { 
                const usernameInput = document.getElementById('reg-u').value.trim(); 
                const passwordInput = document.getElementById('reg-p').value.trim();
                
                if (!usernameInput) {
                    return alert("Please enter a username.");
                }
                
                if (this.database.users[usernameInput]) {
                    if (this.database.users[usernameInput].password === passwordInput || !this.database.users[usernameInput].password) {
                        this.completeAuthentication(usernameInput);
                    } else {
                        alert("Incorrect password!");
                    }
                } else {
                    alert("Account not found! Please click 'Create Account'.");
                }
            },
            
            register() {
                const usernameInput = document.getElementById('reg-u').value.trim();
                const passwordInput = document.getElementById('reg-p').value.trim();
                
                if (!usernameInput) {
                    return alert("Please enter a username.");
                }
                
                if (usernameInput.length < 3) {
                    return alert("Username too short (minimum 3 characters).");
                }
                
                if (this.database.users[usernameInput]) {
                    alert("Username already exists! Please Sign In instead.");
                } else { 
                    this.database.users[usernameInput] = { 
                        password: passwordInput, 
                        achievements: [], 
                        bestScore2048: 0, 
                        totalTilesMerged: 0 
                    }; 
                    
                    this.saveDatabase(); 
                    this.completeAuthentication(usernameInput); 
                }
            },
            
            completeAuthentication(username) { 
                this.currentUser = username; 
                document.getElementById('welcome-msg').innerText = "Hello, " + username; 
                this.navigate('view-home'); 
            },

            navigate(targetViewId) {
                document.getElementById('toast').style.top = "-150px";
                
                const allViews = document.querySelectorAll('.view');
                allViews.forEach(viewElement => {
                    viewElement.classList.remove('active-view');
                });
                
                document.getElementById(targetViewId).classList.add('active-view');
                
                if (targetViewId === 'view-bp') {
                    document.body.style.background = 'var(--bp-bg)';
                    blockPuzzleEngine.initialize();
                } else {
                    document.body.style.background = 'var(--bg-2048)';
                }
                
                if (targetViewId === 'view-stats') {
                    this.updateProfileInterface();
                }
            },
            
            showToast(messageText) {
                const toastElement = document.getElementById('toast'); 
                toastElement.innerText = messageText; 
                toastElement.style.top = "30px";
                
                if (this.toastTimerId) {
                    clearTimeout(this.toastTimerId);
                }
                
                this.toastTimerId = setTimeout(() => { 
                    toastElement.style.top = "-150px"; 
                }, 3000);
            },
            
            saveDatabase() { 
                localStorage.setItem('e2048_platinum_database', JSON.stringify(this.database)); 
            },
            
            grantAchievement(achievementName) {
                if (!this.currentUser) {
                    return;
                }
                
                let userProfile = this.database.users[this.currentUser]; 
                
                if (!userProfile.achievements) {
                    userProfile.achievements = [];
                }
                
                if (!userProfile.achievements.includes(achievementName)) { 
                    userProfile.achievements.push(achievementName); 
                    this.saveDatabase(); 
                    this.showToast("üèÜ " + achievementName); 
                    audioEngine.playWinChime(); 
                }
            },
            
            updateProfileInterface() {
                if (!this.currentUser) {
                    return;
                }
                
                const userProfile = this.database.users[this.currentUser];
                
                document.getElementById('stat-merges').innerText = userProfile.totalTilesMerged || 0;
                document.getElementById('stat-high').innerText = userProfile.bestScore2048 || 0;
                
                const achievementListContainer = document.getElementById('achievements-list'); 
                achievementListContainer.innerHTML = '';
                
                if (!userProfile.achievements || userProfile.achievements.length === 0) {
                    achievementListContainer.innerHTML = '<span style="color:#aaa; font-style:italic;">No achievements yet. Keep playing!</span>';
                } else {
                    userProfile.achievements.forEach(achievement => {
                        const badgeElement = document.createElement('span'); 
                        badgeElement.style = "background:#edc22e; color:white; padding:6px 12px; border-radius:20px; font-size:12px; font-weight:bold;";
                        badgeElement.innerText = achievement; 
                        achievementListContainer.appendChild(badgeElement);
                    });
                }
            },
            
            bindGlobalInputs() {
                let touchStartX, touchStartY; 
                const gameBoardElement = document.getElementById('board-2048');
                
                gameBoardElement.addEventListener('touchstart', event => { 
                    touchStartX = event.touches[0].clientX; 
                    touchStartY = event.touches[0].clientY; 
                }, { passive: true });
                
                gameBoardElement.addEventListener('touchend', event => {
                    let deltaX = event.changedTouches[0].clientX - touchStartX;
                    let deltaY = event.changedTouches[0].clientY - touchStartY;
                    
                    if (Math.abs(deltaX) > 35 || Math.abs(deltaY) > 35) {
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            gameEngine2048.processMove(deltaX > 0 ? 'R' : 'L');
                        } else {
                            gameEngine2048.processMove(deltaY > 0 ? 'D' : 'U');
                        }
                    }
                }, { passive: true });
                
                window.addEventListener('keydown', event => { 
                    if (event.key.includes('Arrow')) {
                        // Extract direction character (U, D, L, R) from ArrowUp, ArrowDown, etc.
                        gameEngine2048.processMove(event.key[5][0]); 
                    }
                });
            }
        };

        /**
         * 2048 ENGINE
         * Manages game grid state, tile spawning, and DOM-diffing renders.
         */
        const gameEngine2048 = {
            logicGrid: [], 
            currentScore: 0, 
            targetValue: 2048, 
            moveHistory: [], 
            countdownTimer: null, 
            timeLeftSeconds: 0, 
            initialTime: 0,
            
            initialize(targetGoal, secondsLimit = 0) {
                this.targetValue = targetGoal; 
                this.currentScore = 0; 
                this.logicGrid = Array(16).fill(null); 
                this.timeLeftSeconds = secondsLimit; 
                this.initialTime = secondsLimit;
                
                document.getElementById('over-2048').style.display = 'none';
                
                if (targetGoal === Infinity) {
                    document.getElementById('display-target').innerText = "ENDLESS";
                } else {
                    document.getElementById('display-target').innerText = targetGoal;
                }
                
                if (secondsLimit > 0) {
                    document.getElementById('timer-row').style.display = 'block';
                    this.beginCountdown();
                } else {
                    document.getElementById('timer-row').style.display = 'none';
                }
                
                clearInterval(this.countdownTimer); 
                
                if (systemManager.currentUser) {
                    document.getElementById('best-2048').innerText = systemManager.database.users[systemManager.currentUser].bestScore2048 || 0;
                }
                
                // Spawn initial two tiles
                this.spawnNewTile(); 
                this.spawnNewTile(); 
                
                this.renderGridToDOM(); 
                systemManager.navigate('view-2048');
            },
            
            beginCountdown() {
                this.countdownTimer = setInterval(() => {
                    this.timeLeftSeconds--; 
                    
                    const minutes = Math.floor(this.timeLeftSeconds / 60);
                    const seconds = this.timeLeftSeconds % 60;
                    
                    let formattedSeconds = seconds;
                    if (seconds < 10) {
                        formattedSeconds = '0' + seconds;
                    }
                    
                    document.getElementById('timer-val').innerText = minutes + ':' + formattedSeconds;
                    
                    if (this.timeLeftSeconds <= 0) { 
                        clearInterval(this.countdownTimer); 
                        this.triggerGameOver("Time's Up!"); 
                    }
                }, 1000);
            },
            
            spawnNewTile() {
    const emptySlotIndices = this.logicGrid.map((value, index) => value === null ? index : null).filter(value => value !== null);
    
    if (emptySlotIndices.length > 0) {
        const randomEmptyIndex = emptySlotIndices[Math.floor(Math.random() * emptySlotIndices.length)];
        
        // Robust ID generation using a counter or high-precision random
        const uniqueId = `tile_${Date.now()}_${Math.floor(Math.random() * 100000)}`;
        
        this.logicGrid[randomEmptyIndex] = { 
            value: Math.random() > 0.9 ? 4 : 2, 
            id: uniqueId,
            isNewlySpawned: true, 
            hasMergedThisTurn: false
        };
    }
        }
        
                    
                    // Generate a robust unique ID for DOM diffing physics
                    const uniqueIdString = 'tile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                    
                    this.logicGrid[randomEmptyIndex] = { 
                        value: newTileValue, 
                        id: uniqueIdString,
                        isNewlySpawned: true, 
                        hasMergedThisTurn: false
                    };
                }
            },
            
            renderGridToDOM() {
                const visualLayer = document.getElementById('tile-layer');
                const currentlyActiveTileIds = new Set();
                
                this.logicGrid.forEach(tile => {
                    if (tile) {
                        currentlyActiveTileIds.add(tile.id);
                    }
                });

                // Phase 1: Remove tiles that have been merged out of existence
                Array.from(visualLayer.children).forEach(domNode => {
                    if (!currentlyActiveTileIds.has(domNode.dataset.id)) {
                        domNode.classList.add('t-dying');
                        domNode.style.zIndex = 5; 
                        
                        // Wait for transition to finish before removing from DOM
                        setTimeout(() => {
                            domNode.remove();
                        }, 150); 
                    }
                });

                // Phase 2: Update positions and values of alive tiles
                this.logicGrid.forEach((tile, gridIndex) => {
                    if (!tile) {
                        return; 
                    }
                    
                    let domNode = document.querySelector(`.tile[data-id='${tile.id}']`);
                    
                    if (!domNode) { 
                        domNode = document.createElement('div'); 
                        domNode.dataset.id = tile.id; 
                        visualLayer.appendChild(domNode); 
                    }
                    
                    // Force DOM reflow to ensure CSS animations trigger correctly
                    void domNode.offsetWidth;
                    
                    const pixelX = (gridIndex % 4) * 82.5; 
                    const pixelY = Math.floor(gridIndex / 4) * 82.5;
                    
                    let classString = `tile t${tile.value > 2048 ? '-super' : tile.value}`;
                    if (tile.isNewlySpawned) {
                        classString += ' t-new';
                    }
                    if (tile.hasMergedThisTurn) {
                        classString += ' t-merged';
                    }
                    
                    domNode.className = classString; 
                    domNode.style.transform = `translate(${pixelX}px, ${pixelY}px)`;
                    domNode.innerText = tile.value; 
                    
                    // Reset animation flags
                    tile.isNewlySpawned = false; 
                    tile.hasMergedThisTurn = false;
                });

                // Update UI Scores
                document.getElementById('score-2048').innerText = this.currentScore;
                
                if (systemManager.currentUser) {
                    if (this.currentScore > systemManager.database.users[systemManager.currentUser].bestScore2048) {
                        systemManager.database.users[systemManager.currentUser].bestScore2048 = this.currentScore; 
                        systemManager.saveDatabase(); 
                    }
                }
            },
            processMove(direction) {
    if (document.getElementById('over-2048').style.display === 'flex') return;
    
    let boardChanged = false;
    this.moveHistory.push(JSON.stringify(this.logicGrid));

    // Map directions to grid calculations
    const getSequence = (i) => {
        if (direction === 'L') return [i*4, i*4+1, i*4+2, i*4+3];
        if (direction === 'R') return [i*4+3, i*4+2, i*4+1, i*4];
        if (direction === 'U') return [i, i+4, i+8, i+12];
        if (direction === 'D') return [i+12, i+8, i+4, i];
    };

    for (let i = 0; i < 4; i++) {
        const indices = getSequence(i);
        const row = indices.map(idx => this.logicGrid[idx]);
        
        // 1. Slide: Remove nulls
        let filtered = row.filter(tile => tile !== null);
        let newRow = [];

        // 2. Merge: Combine adjacent identical values
        for (let j = 0; j < filtered.length; j++) {
            if (j < filtered.length - 1 && filtered[j].value === filtered[j+1].value) {
                const combinedValue = filtered[j].value * 2;
                this.currentScore += combinedValue;
                
                // Merge into the leading tile
                newRow.push({
                    ...filtered[j],
                    value: combinedValue,
                    hasMergedThisTurn: true
                });
                j++; // Skip the next tile as it's now merged
                boardChanged = true;
                audioEngine.playMergeSound();
            } else {
                newRow.push({ ...filtered[j], hasMergedThisTurn: false });
            }
        }

        // 3. Fill: Add nulls back to maintain row length
        while (newRow.length < 4) newRow.push(null);

        // 4. Update Grid: Check if positions actually changed
        indices.forEach((gridIdx, rowIdx) => {
            const oldTile = this.logicGrid[gridIdx];
            const newTile = newRow[rowIdx];
            
            if (JSON.stringify(oldTile) !== JSON.stringify(newTile)) {
                boardChanged = true;
            }
            this.logicGrid[gridIdx] = newTile;
        });
    }

    if (boardChanged) {
        this.spawnNewTile();
        this.renderGridToDOM();
        if (this.isBoardFull() && !this.areValidMovesRemaining()) {
            this.triggerGameOver("Board Locked!");
        }
    } else {
        this.moveHistory.pop();
    }
}
};
                
                for (let i = 0; i < 4; i++) {
                    let tileIndices = calculateRowIndices(i);
                    
                    // Deep copy the row data to avoid altering the history string reference
                    let rowTiles = tileIndices.map(index => {
                        if (this.logicGrid[index]) {
                            return { ...this.logicGrid[index] };
                        } else {
                            return null;
                        }
                    }).filter(value => value !== null);
                    
                    for (let j = 0; j < rowTiles.length - 1; j++) {
                        if (rowTiles[j].value === rowTiles[j + 1].value) {
                            // Merge happens here
                            rowTiles[j].value *= 2; 
                            rowTiles[j].hasMergedThisTurn = true; 
                            this.currentScore += rowTiles[j].value; 
                            
                            rowTiles.splice(j + 1, 1); 
                            boardChanged = true; 
                            
                            audioEngine.playMergeSound();
                            
                            if (systemManager.currentUser) { 
                                systemManager.database.users[systemManager.currentUser].totalTilesMerged++; 
                                systemManager.saveDatabase(); 
                            }
                            
                            if (rowTiles[j].value === this.targetValue) {
                                systemManager.grantAchievement("Master of " + this.targetValue);
                            }
                        }
                    }
                    
                    // Fill remaining empty space in the row
                    while (rowTiles.length < 4) {
                        rowTiles.push(null);
                    }
                    
                    // Check if actual movement occurred and apply back to logic grid
                    tileIndices.forEach((gridIndex, rowIndex) => { 
                        const originalTileString = JSON.stringify(this.logicGrid[gridIndex]);
                        const newTileString = JSON.stringify(rowTiles[rowIndex]);
                        
                        if (originalTileString !== newTileString) {
                            boardChanged = true; 
                        }
                        
                        this.logicGrid[gridIndex] = rowTiles[rowIndex]; 
                    });
                }
                
                if (boardChanged) { 
                    this.spawnNewTile(); 
                    this.renderGridToDOM(); 
                    
                    if (this.isBoardFull() && !this.areValidMovesRemaining()) {
                        this.triggerGameOver("Board Locked!"); 
                    }
                } else {
                    // Revert history push if no move happened
                    this.moveHistory.pop(); 
                }
            },
            
            isBoardFull() { 
                return !this.logicGrid.includes(null); 
            },
            
            areValidMovesRemaining() {
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 3; col++) {
                        // Check horizontal neighbors
                        if (this.logicGrid[row * 4 + col].value === this.logicGrid[row * 4 + col + 1].value) {
                            return true;
                        }
                        // Check vertical neighbors
                        if (this.logicGrid[col * 4 + row].value === this.logicGrid[(col + 1) * 4 + row].value) {
                            return true;
                        }
                    }
                }
                return false;
            },
            
            undoLastMove() { 
                if (this.moveHistory.length > 0) { 
                    const previousStateString = this.moveHistory.pop();
                    this.logicGrid = JSON.parse(previousStateString); 
                    this.renderGridToDOM(); 
                } 
            },
            
            triggerGameOver(messageText) { 
                document.getElementById('over-msg').innerText = messageText; 
                document.getElementById('over-2048').style.display = 'flex'; 
                clearInterval(this.countdownTimer); 
            }
        };

        /**
         * BLOCK PUZZLE ENGINE
         * Manages 8x8 matrix, block shape configurations, and drag-drop line clearing.
         */
        const blockPuzzleEngine = {
            logicBoard: Array(64).fill(0), 
            currentScore: 0,
            
            blockShapes: [ 
                { matrix: [[1,1], [1,1]], colorClass: 'bp-filled-green' }, 
                { matrix: [[1,1,1,1]], colorClass: 'bp-filled-beige' }, 
                { matrix: [[1,1,1], [0,1,0]], colorClass: 'bp-filled-beige' }, 
                { matrix: [[1,0], [1,0], [1,1]], colorClass: 'bp-filled-green' }, 
                { matrix: [[1,1,0], [0,1,1]], colorClass: 'bp-filled-beige' } 
            ],
            
            initialize() {
                this.logicBoard.fill(0); 
                this.currentScore = 0; 
                
                document.getElementById('over-bp').style.display = 'none';
                
                const gridContainer = document.getElementById('bp-grid'); 
                gridContainer.innerHTML = '';
                
                for (let i = 0; i < 64; i++) { 
                    const slotElement = document.createElement('div'); 
                    slotElement.className = 'bp-slot'; 
                    slotElement.id = `bp-c-${i}`; 
                    gridContainer.appendChild(slotElement); 
                }
                
                this.spawnTrayShapes();
            },
            
            spawnTrayShapes() {
                const trayContainer = document.getElementById('tray'); 
                trayContainer.innerHTML = '';
                
                for (let i = 0; i < 3; i++) {
                    const randomShape = this.blockShapes[Math.floor(Math.random() * this.blockShapes.length)];
                    const shapeWrapper = document.createElement('div');
                    
                    shapeWrapper.style.display = 'grid'; 
                    shapeWrapper.style.gridTemplateColumns = `repeat(${randomShape.matrix[0].length}, 20px)`; 
                    shapeWrapper.style.gap = '2px';
                    
                    randomShape.matrix.flat().forEach(cellValue => { 
                        const blockPiece = document.createElement('div'); 
                        blockPiece.style.width = '20px'; 
                        blockPiece.style.height = '20px'; 
                        blockPiece.style.borderRadius = '2px'; 
                        
                        if (cellValue) {
                            blockPiece.className = randomShape.colorClass; 
                        }
                        
                        shapeWrapper.appendChild(blockPiece); 
                    });
                    
                    const handleDragStart = (event) => {
                        let pointerData = event;
                        if (event.touches) {
                            pointerData = event.touches[0];
                        }
                        this.initiateDrag(pointerData, shapeWrapper, randomShape.matrix, randomShape.colorClass);
                    };
                    
                    shapeWrapper.onmousedown = handleDragStart; 
                    shapeWrapper.ontouchstart = handleDragStart; 
                    
                    trayContainer.appendChild(shapeWrapper);
                }
            },
            
            initiateDrag(pointerEvent, sourceElement, shapeMatrix, shapeColorClass) {
                const draggingClone = sourceElement.cloneNode(true); 
                draggingClone.className = 'dragging'; 
                
                // Scale up dragging clone to match board sizes
                draggingClone.style.gridTemplateColumns = `repeat(${shapeMatrix[0].length}, 40px)`;
                
                Array.from(draggingClone.children).forEach(childPiece => { 
                    childPiece.style.width = '40px'; 
                    childPiece.style.height = '40px'; 
                });
                
                document.body.appendChild(draggingClone);
                
                const handlePointerMove = (event) => {
                    let movePointer = event;
                    if (event.touches) {
                        movePointer = event.touches[0];
                    }
                    
                    draggingClone.style.left = (movePointer.clientX - (shapeMatrix[0].length * 20)) + 'px'; 
                    draggingClone.style.top = (movePointer.clientY - (shapeMatrix.length * 60)) + 'px';
                    
                    // Clear previous ghosts
                    document.querySelectorAll('.bp-ghost').forEach(ghostNode => {
                        ghostNode.classList.remove('bp-ghost');
                    });
                    
                    const boardRect = document.getElementById('bp-grid').getBoundingClientRect();
                    const targetColumn = Math.round((movePointer.clientX - boardRect.left - (shapeMatrix[0].length * 20)) / 42);
                    const targetRow = Math.round((movePointer.clientY - boardRect.top - (shapeMatrix.length * 60)) / 42);
                    
                    if (this.validatePlacement(shapeMatrix, targetRow, targetColumn)) {
                        for (let r = 0; r < shapeMatrix.length; r++) {
                            for (let c = 0; c < shapeMatrix[0].length; c++) {
                                if (shapeMatrix[r][c]) {
                                    const index = (targetRow + r) * 8 + (targetColumn + c);
                                    document.getElementById(`bp-c-${index}`).classList.add('bp-ghost');
                                }
                            }
                        }
                    }
                };
                
                const handlePointerEnd = (event) => {
                    let endPointer = event;
                    if (event.changedTouches) {
                        endPointer = event.changedTouches[0];
                    }
                    
                    const boardRect = document.getElementById('bp-grid').getBoundingClientRect();
                    const finalColumn = Math.round((endPointer.clientX - boardRect.left - (shapeMatrix[0].length * 20)) / 42);
                    const finalRow = Math.round((endPointer.clientY - boardRect.top - (shapeMatrix.length * 60)) / 42);
                    
                    if (this.validatePlacement(shapeMatrix, finalRow, finalColumn)) {
                        for (let r = 0; r < shapeMatrix.length; r++) {
                            for (let c = 0; c < shapeMatrix[0].length; c++) {
                                if (shapeMatrix[r][c]) { 
                                    const index = (finalRow + r) * 8 + (finalColumn + c);
                                    this.logicBoard[index] = 1; 
                                    document.getElementById(`bp-c-${index}`).className = `bp-slot ${shapeColorClass}`; 
                                }
                            }
                        }
                        
                        audioEngine.playWoodDropSound(); 
                        sourceElement.style.visibility = 'hidden'; 
                        
                        // Score calculation based on number of blocks placed
                        let blocksInShape = 0;
                        shapeMatrix.flat().forEach(val => { if (val) blocksInShape++; });
                        this.currentScore += (blocksInShape * 10);
                        
                        this.scanAndClearLines(); 
                        document.getElementById('score-bp').innerText = this.currentScore;
                        
                        // Check if tray needs refilling
                        let isTrayEmpty = true;
                        Array.from(sourceElement.parentNode.children).forEach(trayItem => {
                            if (trayItem.style.visibility !== 'hidden') {
                                isTrayEmpty = false;
                            }
                        });
                        
                        if (isTrayEmpty) {
                            this.spawnTrayShapes();
                        }
                    }
                    
                    draggingClone.remove(); 
                    
                    document.querySelectorAll('.bp-ghost').forEach(ghostNode => {
                        ghostNode.classList.remove('bp-ghost');
                    });
                    
                    window.removeEventListener('mousemove', handlePointerMove); 
                    window.removeEventListener('mouseup', handlePointerEnd);
                    window.removeEventListener('touchmove', handlePointerMove); 
                    window.removeEventListener('touchend', handlePointerEnd);
                };
                
                window.addEventListener('mousemove', handlePointerMove); 
                window.addEventListener('mouseup', handlePointerEnd);
                window.addEventListener('touchmove', handlePointerMove, { passive: false }); 
                window.addEventListener('touchend', handlePointerEnd);
            },
            
            validatePlacement(shapeMatrix, targetRow, targetColumn) {
                // Check outer grid boundaries
                if (targetRow < 0 || targetColumn < 0 || targetRow + shapeMatrix.length > 8 || targetColumn + shapeMatrix[0].length > 8) {
                    return false;
                }
                
                // Check internal collisions
                for (let r = 0; r < shapeMatrix.length; r++) {
                    for (let c = 0; c < shapeMatrix[0].length; c++) {
                        if (shapeMatrix[r][c] && this.logicBoard[(targetRow + r) * 8 + (targetColumn + c)]) {
                            return false; 
                        }
                    }
                }
                
                return true;
            },
            
            scanAndClearLines() {
                let fullRows = [];
                let fullColumns = [];
                
                for (let i = 0; i < 8; i++) {
                    // Row Check
                    let isRowFull = true;
                    for (let r = 0; r < 8; r++) {
                        if (this.logicBoard[i * 8 + r] === 0) isRowFull = false;
                    }
                    if (isRowFull) fullRows.push(i);
                    
                    // Column Check
                    let isColFull = true;
                    for (let c = 0; c < 8; c++) {
                        if (this.logicBoard[c * 8 + i] === 0) isColFull = false;
                    }
                    if (isColFull) fullColumns.push(i);
                }
                
                // Visually and logically clear identified lines
                fullRows.forEach(rowIndex => { 
                    for (let x = 0; x < 8; x++) { 
                        this.logicBoard[rowIndex * 8 + x] = 0; 
                        document.getElementById(`bp-c-${rowIndex * 8 + x}`).className = 'bp-slot'; 
                    } 
                });
                
                fullColumns.forEach(colIndex => { 
                    for (let y = 0; y < 8; y++) { 
                        this.logicBoard[y * 8 + colIndex] = 0; 
                        document.getElementById(`bp-c-${y * 8 + colIndex}`).className = 'bp-slot'; 
                    } 
                });
                
                // Apply combo scoring
                if (fullRows.length > 0 || fullColumns.length > 0) { 
                    this.currentScore += (fullRows.length + fullColumns.length) * 100; 
                    audioEngine.playWinChime(); 
                    
                    if (fullRows.length + fullColumns.length >= 3) { 
                        systemManager.grantAchievement("Tetris Master"); 
                    } 
                }
            }
        };

        // Application Bootstrap
        window.onload = () => {
            systemManager.initializeSystem();
        };
    </script>
</body>
</html>
